const worker_threads=require("node:worker_threads"),$t=function(e){return new MessageTaskManager(()=>new worker_threads.Worker(e.getCode(),{eval:!0}))},$et=function(e,t){let s=new Task(null,t).getCode();return s+=`
w.parentPort.postMessage({'return': ${t.name}(${e})});`,new EasyTaskManager(()=>new worker_threads.Worker(s,{eval:!0}))},$tfile=function(e){return new MessageTaskManager(()=>new worker_threads.Worker(e))},waitAll=async e=>new Promise((r,t)=>{let i=new Array(e.length).fill(!1),n=new Array(e.length);e.forEach((e,s)=>{e.then(()=>{return e=s,i[e]=!0,n[e]=t,void(!1 in i||r(n));var e,t}).catch(e=>t(e))})}),waitOrThrowOnTimeout=async(e,i,n="promise did not finish before timeout")=>new Promise((t,s)=>{let r=setTimeout(()=>s(new Error(n)),i);e.then(e=>{clearTimeout(r),t(e)}).catch(e=>{clearTimeout(r),s(e)})}),waitOrReturnOnTimeout=async(e,i)=>new Promise((t,s)=>{let r=setTimeout(()=>t(void 0),i);e.then(e=>{clearTimeout(r),t(e)}).catch(e=>{clearTimeout(r),s(e)})});class TaskManager{static#aliases={};#taskAlias;#worker=void 0;#isOnline=!1;#isFinished=!1;#exitCode=null;#onExitEvents=[];#onErrorEvents=[];#onMessageRecievedEvents={};constructor(e){this.#worker=e(),this.#worker.on("online",()=>{this.#isOnline=!0}),this.#worker.on("exit",t=>{this.#exitCode=t,this.#isFinished=!0,this.#isOnline=!1,this.#onExitEvents.forEach(e=>e(t))}),this.#worker.on("error",t=>{this.#onErrorEvents.forEach(e=>e(t))}),this.#worker.on("message",t=>{const s=Object.keys(t)[0];this.#onMessageRecievedEvents[s].forEach(e=>e(t[s]))}),this.#taskAlias=this.getID()}doOnMessageRecieved(e,t){void 0!==this.#onMessageRecievedEvents[e]?this.#onMessageRecievedEvents[e].push(t):this.#onMessageRecievedEvents[e]=[t]}doOnExit(e){this.#onExitEvents.push(e)}doOnError(e){this.#onErrorEvents.push(e)}async waitForFinish(){return this.getIsFinished()?this.getExitCode():new Promise((t,s)=>{this.doOnExit(e=>t(e)),this.doOnError(e=>s(e))})}async waitForFinishOrThrowOnTimeout(e){return waitOrThrowOnTimeout(this.waitForFinish(),e,"thread did not finish before timeout")}async waitForFinishOrReturnOnTimeout(e){return waitOrReturnOnTimeout(this.waitForFinish(),e)}static async waitAllTasks(a){return new Promise((r,t)=>{let i=[],n={};a.forEach(e=>{const s=e.getAlias();e.waitForFinish().then(e=>{return e=e,t=s,i.push(t),n[t]=e,void(i.length===a.length&&r(n));var t}).catch(e=>t(e))})})}static async waitAnyTasks(e){return new Promise((i,s)=>{e.forEach((e,t)=>{const r=e.getAlias();e.waitForFinish().then(e=>{return e=e,t=r,(s={})[t]=e,void i(s);var t,s}).catch(e=>s(e))})})}getID(){return this.#worker.threadId}kill(){return this.#worker.terminate()}getWorker(){return this.#worker}getIsOnline(){return this.#isOnline}getIsFinished(){return this.#isFinished}getExitCode(){return this.#exitCode}setAlias(e){e=""+e;return!(e in Object.values(TaskManager.#aliases))&&(this.#taskAlias=e,TaskManager.#aliases[this.getID]=e,!0)}getAlias(){return this.#taskAlias}}class MessageTaskManager extends TaskManager{constructor(e){super(e)}sendMessage(e,t){var s={};s[e]=t,this.getWorker().postMessage(s)}async waitForMessageRecieved(s){return new Promise((t,e)=>{this.doOnMessageRecieved(s,e=>t(e))})}async waitForMessageRecievedOrThrowOnTimeout(e,t){return waitOrThrowOnTimeout(this.waitForMessageRecieved(e),t,"message was not received before timeout")}async waitForMessageRecievedOrReturnOnTimeout(e,t){return waitOrReturnOnTimeout(this.waitForMessageRecieved(e),t)}static async waitAllTasksForMessage(a,o){return new Promise((r,t)=>{let i=[],n={};a.forEach(e=>{const s=e.getAlias();e.messageName(o).then(e=>{return e=e,t=s,i.push(t),n[t]=e,void(i.length===a.length&&r(n));var t}).catch(e=>t(e))})})}static async waitAnyTasksForMessage(e,n){return new Promise((i,s)=>{e.forEach((e,t)=>{const r=e.getAlias();e.waitForMessageRecieved(n).then(e=>{return e=e,t=r,(s={})[t]=e,void i(s);var t,s}).catch(e=>s(e))})})}}class EasyTaskManager extends TaskManager{#retVal=void 0;constructor(e){super(e),this.doOnReturn(e=>this.#retVal=e)}doOnReturn(e){super.doOnMessageRecieved("return",e)}async waitForFinish(){return this.getIsFinished()?this.#retVal:new Promise((t,s)=>{this.doOnReturn(e=>t(e)),this.doOnError(e=>s(e)),this.doOnExit(e=>s(e))})}}class Task{#code;constructor(e,t){this.#code=this.#compile(e,t)}#compile(t,e){var s=["const w = require('node:worker_threads');"];if(null!=t&&0!==t.length){s.push("messagesMap = {");const r=[];Object.keys(t).forEach(e=>{r.push(`'${e}': `+t[e])}),s.push(r.join(",\n")),s.push("};"),s.push('w.parentPort.on("message", data => {const key = Object.keys(data)[0]; messagesMap[key](data[key]);});')}return s.push(""+e),s.join("\n")}getCode(){return this.#code}}module.exports={$t:$t,$et:$et,$tfile:$tfile,Task:Task,TaskManager:TaskManager,MessageTaskManager:MessageTaskManager,EasyTaskManager:EasyTaskManager,waitAll:waitAll,waitOrThrowOnTimeout:waitOrThrowOnTimeout,waitOrReturnOnTimeout:waitOrReturnOnTimeout};